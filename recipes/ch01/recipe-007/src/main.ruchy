// Recipe 1.7: Structs, Classes, and Methods
// Implementation written AFTER tests following EXTREME TDD

// ============================================================================
// STRUCTS (Value Semantics)
// ============================================================================

/// Public struct with public fields - plain data (like C structs)
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Rectangle {
    pub width: i32,
    pub height: i32,
}

impl Rectangle {
    /// Associated function (constructor) - creates a square
    pub fun square(size: i32) -> Self {
        Rectangle {
            width: size,
            height: size,
        }
    }

    /// Associated function - create from dimensions
    pub fun from_dimensions(width: i32, height: i32) -> Self {
        Rectangle { width, height }
    }

    /// Instance method - calculates area
    pub fun area(&self) -> i32 {
        self.width * self.height
    }

    /// Instance method - calculates perimeter
    pub fun perimeter(&self) -> i32 {
        2 * (self.width + self.height)
    }

    /// Check if this is a square
    pub fun is_square(&self) -> bool {
        self.width == self.height
    }

    /// MUTATING method - scales the rectangle
    pub mutating fun scale(&mut self, factor: i32) {
        self.width *= factor;
        self.height *= factor;
    }

    /// MUTATING method with chaining - sets width
    pub mutating fun set_width(&mut self, width: i32) -> &mut Self {
        self.width = width;
        self
    }

    /// MUTATING method with chaining - sets height
    pub mutating fun set_height(&mut self, height: i32) -> &mut Self {
        self.height = height;
        self
    }

    /// Creates a doubled version (non-mutating)
    pub fun doubled(&self) -> Self {
        Rectangle {
            width: self.width * 2,
            height: self.height * 2,
        }
    }

    /// Check if this rectangle can hold another
    pub fun can_hold(&self, other: &Rectangle) -> bool {
        self.width >= other.width && self.height >= other.height
    }
}

/// Struct with private fields - encapsulation (class-like behavior with value semantics)
#[derive(Debug, Clone, Copy)]
pub struct Point {
    x: i32,  // Private field
    y: i32,  // Private field
}

impl Point {
    /// Constructor
    pub fun new(x: i32, y: i32) -> Self {
        Point { x, y }
    }

    /// Static constructor - origin point
    pub fun origin() -> Self {
        Point { x: 0, y: 0 }
    }

    /// Static constructor - zero point (alias for origin)
    pub fun zero() -> Self {
        Point { x: 0, y: 0 }
    }

    /// Getter for x (read-only access to private field)
    pub fun x(&self) -> i32 {
        self.x
    }

    /// Getter for y
    pub fun y(&self) -> i32 {
        self.y
    }

    /// Setter for x (controlled write access)
    pub mutating fun set_x(&mut self, x: i32) {
        self.x = x;
    }

    /// Setter for y
    pub mutating fun set_y(&mut self, y: i32) {
        self.y = y;
    }

    /// Calculate distance to another point
    pub fun distance(&self, other: &Point) -> f64 {
        let dx = (self.x - other.x) as f64;
        let dy = (self.y - other.y) as f64;
        (dx * dx + dy * dy).sqrt()
    }

    /// Check equality with another point
    pub fun equals(&self, other: &Point) -> bool {
        self.x == other.x && self.y == other.y
    }
}

/// Stateful struct - counter with value semantics
#[derive(Debug, Clone, Copy)]
pub struct Counter {
    value: i32,
}

impl Counter {
    /// Create new counter at zero
    pub fun new() -> Self {
        Counter { value: 0 }
    }

    /// Get current value
    pub fun value(&self) -> i32 {
        self.value
    }

    /// Increment counter
    pub mutating fun increment(&mut self) {
        self.value += 1;
    }

    /// Decrement counter
    pub mutating fun decrement(&mut self) {
        self.value -= 1;
    }

    /// Reset counter to zero
    pub mutating fun reset(&mut self) {
        self.value = 0;
    }
}

/// Configuration struct (result of builder)
#[derive(Debug, Clone)]
pub struct Config {
    host: String,
    port: i32,
    timeout: i32,
}

impl Config {
    pub fun host(&self) -> &str {
        &self.host
    }

    pub fun port(&self) -> i32 {
        self.port
    }

    pub fun timeout(&self) -> i32 {
        self.timeout
    }
}

/// Builder pattern for Config (struct-based)
pub struct ConfigBuilder {
    host: Option<String>,
    port: Option<i32>,
    timeout: Option<i32>,
}

impl ConfigBuilder {
    /// Start building a Config
    pub fun new() -> Self {
        ConfigBuilder {
            host: None,
            port: None,
            timeout: None,
        }
    }

    /// Set host (fluent interface)
    pub fun host(mut self, host: &str) -> Self {
        self.host = Some(host.to_string());
        self
    }

    /// Set port
    pub fun port(mut self, port: i32) -> Self {
        self.port = Some(port);
        self
    }

    /// Set timeout
    pub fun timeout(mut self, timeout: i32) -> Self {
        self.timeout = Some(timeout);
        self
    }

    /// Build the Config
    pub fun build(self) -> Config {
        Config {
            host: self.host.unwrap_or_else(|| "localhost".to_string()),
            port: self.port.unwrap_or(80),
            timeout: self.timeout.unwrap_or(60),
        }
    }
}

// ============================================================================
// CLASSES (Reference Semantics)
// ============================================================================

/// Person class - reference type with explicit init
#[derive(Debug, Clone, PartialEq)]
pub class Person {
    name: String,
    age: i32,

    /// Required init method for classes
    init(name: &str, age: i32) {
        self.name = name.to_string();
        self.age = age;
    }

    /// Getter for name
    fun name(&self) -> &str {
        &self.name
    }

    /// Getter for age
    fun age(&self) -> i32 {
        self.age
    }

    /// Setter for name (no 'mutating' keyword needed for classes!)
    fun set_name(&self, name: &str) -> &Self {
        self.name = name.to_string();
        self  // Return self for chaining
    }

    /// Setter for age
    fun set_age(&self, age: i32) -> &Self {
        self.age = age;
        self  // Return self for chaining
    }

    /// Increment age (no 'mutating' keyword needed!)
    fun have_birthday(&self) {
        self.age += 1;
    }

    /// Check if same age as another person
    fun same_age(&self, other: &Person) -> bool {
        self.age == other.age
    }
}

/// BankAccount class - reference type demonstrating shared state
#[derive(Debug, Clone, PartialEq)]
pub class BankAccount {
    owner: String,
    pub balance: f64,  // Public field in class

    /// Init method
    init(owner: &str, initial_balance: f64) {
        self.owner = owner.to_string();
        self.balance = initial_balance;
    }

    /// Static method - create savings account
    static fun savings_account(owner: &str) -> Self {
        BankAccount::init(owner, 0.0)
    }

    /// Static method - create checking account
    static fun checking_account(owner: &str, initial: f64) -> Self {
        BankAccount::init(owner, initial)
    }

    /// Get owner
    fun owner(&self) -> &str {
        &self.owner
    }

    /// Get balance
    fun balance(&self) -> f64 {
        self.balance
    }

    /// Deposit money (no 'mutating' needed!)
    fun deposit(&self, amount: f64) {
        self.balance += amount;
    }

    /// Withdraw money
    fun withdraw(&self, amount: f64) {
        self.balance -= amount;
    }
}

/// SharedCounter class - demonstrates reference semantics
#[derive(Debug, Clone, PartialEq)]
pub class SharedCounter {
    value: i32,

    /// Init method
    init(initial: i32) {
        self.value = initial;
    }

    /// Get current value
    fun value(&self) -> i32 {
        self.value
    }

    /// Increment (no 'mutating' needed - reference semantics!)
    fun increment(&self) {
        self.value += 1;
    }

    /// Decrement
    fun decrement(&self) {
        self.value -= 1;
    }

    /// Reset to zero
    fun reset(&self) {
        self.value = 0;
    }
}

// ============================================================================
// MAIN FUNCTION - Demonstrates struct vs class
// ============================================================================

fun main() {
    println!("=== STRUCT EXAMPLES (Value Semantics) ===\n");

    // 1. Basic struct with public fields
    let rect = Rectangle { width: 30, height: 50 };
    println!("Rectangle: {}x{}", rect.width, rect.height);
    println!("Area: {}", rect.area());
    println!("Perimeter: {}", rect.perimeter());

    // 2. Struct copy semantics
    let rect1 = Rectangle { width: 10, height: 20 };
    let mut rect2 = rect1;  // COPIES the struct
    rect2.width = 30;

    println!("\nStruct copy semantics:");
    println!("rect1.width: {} (unchanged)", rect1.width);
    println!("rect2.width: {} (modified copy)", rect2.width);

    // 3. Struct with private fields (encapsulation)
    let p1 = Point::new(10, 20);
    let p2 = Point::new(13, 24);
    println!("\nPoint distance: {}", p1.distance(&p2));

    // 4. Associated functions (constructors)
    let square = Rectangle::square(20);
    println!("Square: {}x{}", square.width, square.height);

    // 5. Method chaining with struct
    let mut rect3 = Rectangle { width: 5, height: 10 };
    rect3.set_width(15).set_height(20).scale(2);
    println!("After chaining: {}x{}", rect3.width, rect3.height);

    println!("\n=== CLASS EXAMPLES (Reference Semantics) ===\n");

    // 6. Class with init method
    let person = Person("Alice", 30);
    println!("Person: {} (age {})", person.name(), person.age());

    // 7. Class reference semantics (SHARED on assignment)
    let person1 = Person("Bob", 25);
    let person2 = person1;  // SHARES the reference, no copy!

    person2.set_age(26);

    println!("\nClass reference semantics:");
    println!("person1.age(): {} (changed!)", person1.age());
    println!("person2.age(): {} (same instance)", person2.age());
    println!("Same identity: {}", person1 === person2);

    // 8. Class with multiple references
    let account = BankAccount("Carol", 1000.0);
    let account_ref1 = account;
    let account_ref2 = account;

    account_ref1.deposit(100.0);
    account_ref2.deposit(50.0);

    println!("\nShared bank account:");
    println!("account.balance(): {}", account.balance());
    println!("account_ref1.balance(): {}", account_ref1.balance());
    println!("account_ref2.balance(): {}", account_ref2.balance());

    // 9. Builder pattern (struct-based)
    let config = ConfigBuilder::new()
        .host("localhost")
        .port(8080)
        .timeout(30)
        .build();

    println!("\nConfig built: {}:{} (timeout: {}s)",
        config.host(), config.port(), config.timeout());

    // 10. Struct counter vs Class counter
    println!("\n=== Counter Comparison ===\n");

    // Struct counter (independent copies)
    let mut counter1 = Counter::new();
    let mut counter2 = counter1;  // COPY

    counter1.increment();
    counter2.increment();
    counter2.increment();

    println!("Struct Counter (value semantics):");
    println!("counter1: {}", counter1.value());
    println!("counter2: {}", counter2.value());

    // Class counter (shared reference)
    let counter_a = SharedCounter(0);
    let counter_b = counter_a;  // SHARE

    counter_a.increment();
    counter_b.increment();
    counter_a.increment();

    println!("\nClass Counter (reference semantics):");
    println!("counter_a: {}", counter_a.value());
    println!("counter_b: {}", counter_b.value());
    println!("Same instance: {}", counter_a === counter_b);
}
