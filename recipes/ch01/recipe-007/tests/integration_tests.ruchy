// Integration tests for Recipe 1.7: Structs, Classes, and Methods
// Testing real-world OO usage patterns that demonstrate struct vs class

use std::testing::*;

// ============================================================================
// STRUCT INTEGRATION TESTS (Value Semantics in Practice)
// ============================================================================

#[test]
fun test_geometry_calculator_workflow() {
    // Workflow: Calculate properties of geometric shapes (struct-based)
    let rect1 = Rectangle { width: 30, height: 40 };
    let rect2 = Rectangle { width: 20, height: 30 };

    // Calculate areas
    let total_area = rect1.area() + rect2.area();
    assert_eq!(total_area, 1200 + 600);

    // Test containment
    let small = Rectangle { width: 10, height: 15 };
    assert!(rect1.can_hold(&small));
    assert!(rect2.can_hold(&small));

    // Create squares
    let square = Rectangle::square(25);
    assert!(square.is_square());
    assert_eq!(square.area(), 625);
}

#[test]
fun test_point_geometry_system() {
    // Workflow: Coordinate system calculations (struct-based)
    let origin = Point::zero();
    let p1 = Point::new(3, 4);
    let p2 = Point::new(6, 8);

    // Verify Euclidean distances
    assert_eq!(origin.distance(&p1), 5.0);
    assert_eq!(origin.distance(&p2), 10.0);

    // Test triangle: origin, p1, p2 are collinear
    let d_op1 = origin.distance(&p1);
    let d_p1p2 = p1.distance(&p2);
    let d_op2 = origin.distance(&p2);

    assert!((d_op2 - (d_op1 + d_p1p2)).abs() < 0.0001);
}

#[test]
fun test_struct_copy_in_collection() {
    // Workflow: Storing structs in collections (value semantics)
    let mut points = vec![
        Point::new(0, 0),
        Point::new(1, 1),
        Point::new(2, 2),
    ];

    // Modify a copy - original in vec unchanged
    let mut point_copy = points[1];
    point_copy.set_x(10);

    assert_eq!(points[1].x(), 1);  // Original unchanged
    assert_eq!(point_copy.x(), 10);  // Copy modified
}

#[test]
fun test_rectangle_transformation_pipeline() {
    // Workflow: Transform shapes through pipeline (struct method chaining)
    let mut rect = Rectangle { width: 5, height: 10 };

    // Apply transformations
    rect.set_width(10)
        .set_height(20)
        .scale(2);

    assert_eq!(rect.width, 20);
    assert_eq!(rect.height, 40);
    assert_eq!(rect.area(), 800);
}

#[test]
fun test_independent_struct_counters() {
    // Workflow: Multiple independent counters (value semantics)
    let mut counter1 = Counter::new();
    let mut counter2 = Counter::new();

    counter1.increment();
    counter1.increment();

    counter2.increment();
    counter2.increment();
    counter2.increment();

    // Each counter maintains independent state
    assert_eq!(counter1.value(), 2);
    assert_eq!(counter2.value(), 3);
}

// ============================================================================
// CLASS INTEGRATION TESTS (Reference Semantics in Practice)
// ============================================================================

#[test]
fun test_bank_account_transactions() {
    // Workflow: Bank account with multiple transaction references (class)
    let account = BankAccount("Alice", 1000.0);
    let account_ref1 = account;  // Share reference
    let account_ref2 = account;  // Share reference

    // Transaction through different references
    account_ref1.deposit(100.0);
    account_ref2.deposit(200.0);
    account.withdraw(50.0);

    // All references see the same final balance
    assert_eq!(account.balance(), 1250.0);
    assert_eq!(account_ref1.balance(), 1250.0);
    assert_eq!(account_ref2.balance(), 1250.0);

    // All are the same instance
    assert!(account === account_ref1);
    assert!(account_ref1 === account_ref2);
}

#[test]
fun test_person_lifecycle_workflow() {
    // Workflow: Person object lifecycle with aging (class)
    let person = Person("Bob", 25);
    let person_ref = person;  // Share reference

    // Simulate 5 years passing
    for _ in 0..5 {
        person.have_birthday();
    }

    // All references see updated age
    assert_eq!(person.age(), 30);
    assert_eq!(person_ref.age(), 30);

    // Update name through one reference
    person.set_name("Robert");

    // All references see updated name
    assert_eq!(person.name(), "Robert");
    assert_eq!(person_ref.name(), "Robert");
}

#[test]
fun test_shared_counter_workflow() {
    // Workflow: Shared counter accessed by multiple references (class)
    let counter = SharedCounter(0);
    let ref1 = counter;
    let ref2 = counter;
    let ref3 = counter;

    // Increment through different references
    ref1.increment();
    ref2.increment();
    ref3.increment();
    counter.increment();

    // All see the accumulated value
    assert_eq!(counter.value(), 4);
    assert_eq!(ref1.value(), 4);
    assert_eq!(ref2.value(), 4);
    assert_eq!(ref3.value(), 4);
}

#[test]
fun test_class_in_data_structure() {
    // Workflow: Classes in collections share references
    let person1 = Person("Carol", 35);
    let person2 = Person("Dave", 40);

    let people = vec![person1, person2];

    // Modify through vector
    people[0].have_birthday();

    // Original reference sees the change (shared instance)
    assert_eq!(person1.age(), 36);
    assert_eq!(people[0].age(), 36);

    // Still the same instance
    assert!(person1 === people[0]);
}

#[test]
fun test_bank_account_factory_methods() {
    // Workflow: Creating accounts with factory methods (class)
    let savings = BankAccount::savings_account("Eve");
    let checking = BankAccount::checking_account("Frank", 500.0);

    savings.deposit(1000.0);
    checking.withdraw(100.0);

    assert_eq!(savings.balance(), 1000.0);
    assert_eq!(checking.balance(), 400.0);
}

// ============================================================================
// MIXED WORKFLOWS (Struct vs Class Comparison)
// ============================================================================

#[test]
fun test_struct_vs_class_copy_behavior() {
    // Compare: Struct copy vs Class reference sharing

    // Struct: Copies on assignment
    let rect1 = Rectangle { width: 10, height: 20 };
    let mut rect2 = rect1;  // COPY
    rect2.width = 30;

    assert_eq!(rect1.width, 10);  // Original unchanged
    assert_eq!(rect2.width, 30);  // Copy modified

    // Class: Shares reference on assignment
    let person1 = Person("Grace", 28);
    let person2 = person1;  // SHARE
    person2.set_age(29);

    assert_eq!(person1.age(), 29);  // Original changed!
    assert_eq!(person2.age(), 29);  // Both see same change
    assert!(person1 === person2);  // Same instance
}

#[test]
fun test_builder_pattern_for_config() {
    // Workflow: Building configuration with builder pattern (struct-based)
    let config1 = ConfigBuilder::new()
        .host("localhost")
        .port(8080)
        .timeout(30)
        .build();

    let config2 = ConfigBuilder::new()
        .host("example.com")
        .port(443)
        .build();  // Uses default timeout

    assert_eq!(config1.host(), "localhost");
    assert_eq!(config1.port(), 8080);
    assert_eq!(config1.timeout(), 30);

    assert_eq!(config2.host(), "example.com");
    assert_eq!(config2.port(), 443);
    assert_eq!(config2.timeout(), 60);  // Default
}

#[test]
fun test_encapsulation_workflow() {
    // Workflow: Private fields enforce encapsulation (struct)
    let mut point = Point::new(5, 10);

    // Cannot access private fields
    // let x = point.x;  // ERROR: field is private

    // Must use public interface
    assert_eq!(point.x(), 5);
    point.set_x(15);
    assert_eq!(point.x(), 15);

    // Calculate distance using public method
    let other = Point::new(18, 14);
    assert_eq!(point.distance(&other), 5.0);
}

#[test]
fun test_static_methods_workflow() {
    // Workflow: Using static/associated functions

    // Struct static methods
    let origin = Point::origin();
    let zero = Point::zero();
    assert!(origin.equals(&zero));

    // Class static methods
    let account1 = BankAccount::savings_account("Helen");
    let account2 = BankAccount::checking_account("Ian", 250.0);

    assert_eq!(account1.balance(), 0.0);
    assert_eq!(account2.balance(), 250.0);
}
