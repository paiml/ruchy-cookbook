// Recipe 1.3: Variables and Mutability
//
// Demonstrates Ruchy's variable features:
// - Immutable variables with 'let'
// - Mutable variables with 'let mut'
// - Type annotations
// - Shadowing
// - Type inference
// - Scopes
//
// Written using EXTREME TDD - all features tested and verified to work

// ============================================
// IMMUTABLE VARIABLES
// ============================================

fun demonstrate_immutable_variables() {
    println("=== Immutable Variables ===")

    // Basic immutable variable
    let x = 5
    println("x = {}", x)

    // With type annotation
    let y: i32 = 10
    println("y = {}", y)

    // Different types
    let name = "Alice"
    let age = 30
    let height = 5.6
    let is_student = false

    println("name: {}, age: {}, height: {}, student: {}", name, age, height, is_student)
    println("")
}

// ============================================
// MUTABLE VARIABLES
// ============================================

fun demonstrate_mutable_variables() {
    println("=== Mutable Variables ===")

    // Mutable variable with 'mut' keyword
    let mut counter = 0
    println("Initial counter: {}", counter)

    counter = counter + 1
    println("After increment: {}", counter)

    counter = counter + 5
    println("After adding 5: {}", counter)

    // Mutable string
    let mut message = "Hello"
    println("Initial message: {}", message)

    message = "World"
    println("Updated message: {}", message)

    // Multiple mutable variables
    let mut a = 10
    let mut b = 20
    a = a * 2
    b = b + 5

    println("a = {}, b = {}", a, b)
    println("")
}

// ============================================
// SHADOWING
// ============================================

fun demonstrate_shadowing() {
    println("=== Shadowing ===")

    // Shadowing allows reusing variable name
    let x = 5
    println("First x: {}", x)

    let x = 10
    println("Second x (shadowed): {}", x)

    let x = x * 2
    println("Third x (transformed): {}", x)

    // Shadowing can change type
    let value = 42
    println("value as number: {}", value)

    let value = "forty-two"
    println("value as string: {}", value)

    println("")
}

// ============================================
// SCOPES
// ============================================

fun demonstrate_scopes() {
    println("=== Scopes ===")

    let outer = 5
    println("Outer variable: {}", outer)

    // Scope block
    let inner_result = {
        let inner = 10
        println("Inner variable: {}", inner)
        inner + outer
    }

    println("Result from inner scope: {}", inner_result)
    println("Outer variable still: {}", outer)

    // Important: In Ruchy, 'let x' inside a scope MUTATES outer x!
    let y = 5
    println("y before scope: {}", y)

    let result = {
        let y = 10  // This mutates outer y, not shadow!
        y
    }

    println("y after scope: {} (was mutated!)", y)
    println("")
}

// ============================================
// TYPE INFERENCE
// ============================================

fun demonstrate_type_inference() {
    println("=== Type Inference ===")

    // Ruchy infers types from values
    let integer = 42
    let float = 3.14
    let text = "Hello"
    let flag = true

    println("integer: {}", integer)
    println("float: {}", float)
    println("text: {}", text)
    println("flag: {}", flag)

    // Type inference from operations
    let sum = 10 + 20
    let product = 5 * 3
    let quotient = 100.0 / 3.0

    println("sum: {}", sum)
    println("product: {}", product)
    println("quotient: {}", quotient)

    println("")
}

// ============================================
// REAL-WORLD EXAMPLES
// ============================================

fun demonstrate_real_world() {
    println("=== Real-World Examples ===")

    // Example 1: Counter
    let mut count = 0
    count = count + 1
    count = count + 1
    count = count + 1
    println("Items counted: {}", count)

    // Example 2: Configuration flags
    let debug_mode = true
    let verbose = false
    println("Debug: {}, Verbose: {}", debug_mode, verbose)

    // Example 3: Data transformation
    let raw_input = "42"
    let raw_input = 42  // Shadow to change type
    let doubled = raw_input * 2
    println("Transformed: {}", doubled)

    // Example 4: Accumulator pattern
    let mut total = 0.0
    total = total + 10.5
    total = total + 20.3
    total = total + 5.2
    println("Total: {}", total)

    println("")
}

// ============================================
// MAIN
// ============================================

fun main() {
    println("╔═══════════════════════════════════════════════════╗")
    println("║  Recipe 1.3: Variables and Mutability            ║")
    println("║  (Based on EXTREME TDD - all features tested!)    ║")
    println("╚═══════════════════════════════════════════════════╝")
    println("")

    demonstrate_immutable_variables()
    demonstrate_mutable_variables()
    demonstrate_shadowing()
    demonstrate_scopes()
    demonstrate_type_inference()
    demonstrate_real_world()

    println("╔═══════════════════════════════════════════════════╗")
    println("║  Key Takeaways                                    ║")
    println("╠═══════════════════════════════════════════════════╣")
    println("║  ✅ let creates immutable variables               ║")
    println("║  ✅ let mut allows reassignment                   ║")
    println("║  ✅ Shadowing reuses variable names               ║")
    println("║  ✅ Type inference works automatically            ║")
    println("║  ⚠️  Scoped 'let' MUTATES outer variable          ║")
    println("║  ⚠️  No underscore separators (1_000 fails)       ║")
    println("╚═══════════════════════════════════════════════════╝")
}
